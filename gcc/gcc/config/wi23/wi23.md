;; Machine description for wi23
;; Copyright (C) 2009-2022 Free Software Foundation, Inc.

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published
;; by the Free Software Foundation; either version 3, or (at your
;; option) any later version.

;; GCC is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; -------------------------------------------------------------------------
;; Wi23 specific constraints, predicates and attributes
;; -------------------------------------------------------------------------

(include "constraints.md")
(include "predicates.md")

;; Register numbers
(define_constants
  [
    (GP_ARG_FIRST     1)
    (GP_ARG_LAST      8)
    (RET_VAL_REGNUM   9)
    (FP_ARG_FIRST     33)
    (FP_ARG_LAST      40)
    (FP_REGNUM        28)
    (SP_REGNUM        29)
    (RA_REGNUM        30)
    (CSR_REGNUM       31)
    (FCSR_REGNUM      63)
    (AP_REGNUM        64)
    (SFP_REGNUM       65)
  ]
)

;; -------------------------------------------------------------------------
;; nop instruction
;; -------------------------------------------------------------------------

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

;; -------------------------------------------------------------------------
;; Arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "addsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
          (plus:SI
           (match_operand:SI 1 "register_operand" "r,r")
           (match_operand:SI 2 "reg_or_s16_operand" "I,r")))]
  ""
  "@
  addi %0,%1,%2
  add %0,%1,%2")

;; Sub order is flipped in WI-23 so we have to be careful
(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
          (minus:SI
           (match_operand:SI 1 "reg_or_s16_operand" "I,r")
           (match_operand:SI 2 "register_operand" "r,r")))]
  ""
  "@
  subi %0,%2,%1
  sub %0,%2,%1")

;; TODO implement integer multiply/divide using FP instructions

;; implement inversion using a sequence of instructions

;; -------------------------------------------------------------------------
;; Logical operators
;; -------------------------------------------------------------------------

(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (and:SI (match_operand:SI 1 "register_operand" "r,r")
                (not:SI (match_operand:SI 2 "reg_or_u16_operand"  "J,r"))))]
  ""
  "@
  andni %0,%1,%2
  andn %0,%1,%2")

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (xor:SI (match_operand:SI 1 "register_operand" "r,r")
                (match_operand:SI 2 "reg_or_u16_operand"  "J,r")))]
  ""
  "@
  xori %0,%1,%2
  xor %0,%1,%2")
;; -------------------------------------------------------------------------
;; Shifters
;; -------------------------------------------------------------------------
;; TODO - need to make a modifier to handle the shift operand?
(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (lshiftrt:SI (match_operand:SI 1 "register_operand" "r,r")
                     (match_operand:SI 2 "shft_reg_or_u5_operand" "L,r")))]
  ""
  "@
  srli %0,%1,%2
  srl %0,%1,%2")

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ashift:SI (match_operand:SI 1 "register_operand" "r,r")
                     (match_operand:SI 2 "shft_reg_or_u5_operand" "L,r")))]
  ""
  "@
  srli %0,%1,%2
  srl %0,%1,%2")

;; -------------------------------------------------------------------------
;; Move instructions
;; -------------------------------------------------------------------------

;; SImode

(define_insn "movsi_push"
  [(set (mem:SI (pre_dec:SI (reg:SI SP_REGNUM)))
  	(match_operand:SI 0 "register_operand" "r"))]
  ""
  "stu %0, sp, -4")

(define_insn "movsi_pop"
  [(set (match_operand:SI 0 "register_operand" "=r")
  	(mem:SI (post_inc:SI (reg:SI SP_REGNUM))))]
  ""
  "ld %0, sp, 0; addi sp, sp, 4;")

(define_expand "movsi"
   [(set (match_operand:SI 0 "general_operand" "")
        (match_operand:SI 1 "general_operand" ""))]
   ""
{
  /* If this is a store, force the value into a register.  */
  if (!(reload_in_progress || reload_completed))
    {
      if (MEM_P (operands[0]))
        {
          operands[1] = force_reg (SImode, operands[1]);
          if (MEM_P (XEXP (operands[0], 0)))
            operands[0] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[0], 0)));
        }
      else
        {
          if (MEM_P (operands[1]) && MEM_P (XEXP (operands[1], 0)))
            operands[1] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[1], 0)));
        }
    }
})

(define_insn "*movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand"         "=r,r ,BW,r ,r,r")
        (match_operand:SI 1 "wi23_general_movsrc_operand"   "r,rO,r ,BW,i,e"))]
  "register_operand (operands[0], SImode) || reg_or_0_operand (operands[1], SImode)"
  "@
   addi %0, %1, 0
   addi %0, r0, 0
   st %1, %0
   ld %0, %1
   *return wi23_load_immediate(operands[0], INTVAL(operands[1]), false);
   ldcr %0, %1"
)

;; -------------------------------------------------------------------------
;; Comparisons
;; -------------------------------------------------------------------------
(define_predicate "wi23_compare_operator"
  (match_code "eq,lt,le,ltu,leu"))

(define_insn "*setsi4"
  [(set (match_operand:SI 0 "register_operand" "=r") 
    (match_operator 1 "wi23_compare_operator"
			[(match_operand:SI 2 "register_operand" "r")
			  (match_operand:SI 3 "register_operand" "r")]))]
  ""
  "s%C1 %0,%2,%3")

;; -------------------------------------------------------------------------
;; Branch instructions
;; -------------------------------------------------------------------------
(define_predicate "branch_operator"
  (match_code "eq,ne,lt,ge"))

(define_insn "*branchsi"
  [(set (pc)
	(if_then_else
	 (match_operator 1 "branch_operator"
			 [(match_operand:SI 2 "register_operand" "r")
			  (const_int 0)])
	 (label_ref (match_operand 0 "" ""))
	 (pc)))]
  ""
  "b%C1z\t%2,%l0")

(define_expand "cbranchsi4"
  [(set (pc)
	(if_then_else (match_operator 0 "comparison_operator"
		      [(match_operand:SI 1 "register_operand")
		       (match_operand:SI 2 "nonmemory_operand")])
		      (label_ref (match_operand 3 ""))
		      (pc)))]
  ""
{
  wi23_expand_conditional_branch (operands[3], GET_CODE (operands[0]),
				   operands[1], operands[2]);
  DONE;
})

;; -------------------------------------------------------------------------
;; Prologue & Epilogues
;; -------------------------------------------------------------------------

(define_expand "prologue"
  [(clobber (const_int 0))]
  ""
  "
{
  wi23_expand_prologue ();
  DONE;
}
")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  wi23_expand_epilogue ();
  DONE;
}
")

(define_insn "returner"
  [(return)]
  "reload_completed"
  "ld fp, sp, 0; ld ra, sp, 4; addi sp, sp, 8; jr ra;"
)

;; -------------------------------------------------------------------------
;; Call and Jump instructions
;; -------------------------------------------------------------------------

(define_expand "call"
  [(call (match_operand:SI 0 "memory_operand" "")
		(match_operand 1 "general_operand" ""))]
  ""
{
  gcc_assert (MEM_P (operands[0]));
})

;; (clobber (reg:SI RA_REGNUM))

(define_insn "*call"
  [(call (mem:SI (match_operand:SI
		  0 "nonmemory_operand" "i,BW"))
	 (match_operand 1 "" ""))]
  ""
  "@
   jal 0; stu ra, sp, -4; stu fp, sp, -4; jal %0;
   jal 0; stu ra, sp, -4; stu fp, sp, -4; jalr %0;")

(define_expand "call_value"
  [(set (match_operand 0 "" "")
		(call (match_operand:SI 1 "memory_operand" "")
		 (match_operand 2 "" "")))]
  ""
{
  gcc_assert (MEM_P (operands[1]));
})

;; (clobber (reg:SI RA_REGNUM))

(define_insn "*call_value"
  [(set (match_operand 0 "register_operand" "=r,r")
	(call (mem:SI (match_operand:SI
		       1 "nonmemory_operand" "i,BW"))
	      (match_operand 2 "" "")))]
  ""
  "@
  jal 0; stu ra, sp, -4; stu fp, sp, -4; jal %1;
  jal 0; stu ra, sp, -4; stu fp, sp, -4; jalr %1;")

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "nonimmediate_operand" "BW"))]
  ""
  "jr %0")

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "j %l0")
